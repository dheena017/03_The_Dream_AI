"""
BRIDGE - THE NEURAL CONNECTION (SIMPLIFIED MODE)
Autonomous task processing without Flask dependency
"""

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), ".."))

from evolution import developer

# Try optional modules
ai_architect = None
brain_learner = None
reflector_module = None

try:
    from evolution import innovator
except ImportError as e:
    print(f"‚ö†Ô∏è Innovator not available: {e}")
    innovator = None

try:
    from memory import learner
except ImportError:
    print("‚ö†Ô∏è Memory module not found.")
    learner = None

try:
    from evolution import reflector
    reflector_module = reflector
except ImportError:
    print("‚ö†Ô∏è Reflector module not found.")
    reflector_module = None

import datetime
import threading
import time

print("\nüß† DREAM AI - BRIDGE SYSTEM STARTED (AUTONOMOUS MODE)")
print("   üì¨ Task Inbox: brain/tasks.txt")
print("   üìö Wisdom Log: brain/wisdom.txt")
print("   üß¨ Phase 3: Self-Evolving Mode ACTIVE")

# Initialize the Innovator (The Architect)
if innovator:
    try:
        ai_architect = innovator.Innovator()
        print("üß† INNOVATOR MODULE: CONNECTED")
    except Exception as e:
        print(f"‚ö†Ô∏è Innovator module found but failed to load: {e}")
else:
    print("‚ö†Ô∏è Innovator module unavailable - will process user tasks only")

tasks_path = os.path.join(os.path.dirname(__file__), "tasks.txt")
evolution_log = []
idle_cycles = 0

# Ensure inbox exists
if not os.path.exists(tasks_path):
    open(tasks_path, "a", encoding="utf-8").close()

print("‚úÖ Ready for tasks. Listening on tasks.txt...")

def autonomous_loop():
    """
    Main autonomous loop:
    1. Checks for user tasks.
    2. If no user tasks, creates its own tasks (Innovator).
    """
    global idle_cycles

    while True:
        try:
            # Read inbox
            with open(tasks_path, "r", encoding="utf-8") as f:
                task_text = f.read().strip()

            # --- IF NO TASK FOUND ---
            if not task_text:
                idle_cycles += 1
                
                # Every 30 seconds (3 cycles), if bored, try to invent a task
                if idle_cycles % 3 == 0 and ai_architect:
                    print("üí§ Inbox empty. Dreaming of improvements...")
                    try:
                        ai_architect.run_autonomy()
                        # Loop will catch the new task immediately next cycle
                    except Exception as e:
                        print(f"‚ùå Autonomy Error: {e}")
                
                time.sleep(10)
                continue

            # --- IF TASK FOUND ---
            idle_cycles = 0
            print(f"\nüì© NEW TASK RECEIVED: {task_text}")
            print("üß† BRAIN ACTIVATED. Thinking...")

            # Call the Developer (The Builder) safely
            filename = None
            try:
                dev_instance = developer.Developer()
                filename = dev_instance.generate_solution(task_text)
            except Exception as e:
                print(f"‚ùå Execution Error: {e}")

            # Learning step
            if learner and filename:
                try:
                    brain_learner = learner.Learner()
                    brain_learner.digest_code(filename, task_text)
                except Exception as e:
                    print(f"‚ùå Learning Failed: {e}")

            # Clear inbox immediately to prevent loops
            with open(tasks_path, "w", encoding="utf-8") as f:
                f.write("")

            result = {
                "success": True,
                "task": task_text,
                "filename": filename,
                "autonomous": True,
                "timestamp": datetime.datetime.now().isoformat()
            }

            evolution_log.append(result)

            print(f"‚úÖ JOB DONE. File created: {filename}")
            
            # Reflection step
            if reflector_module:
                try:
                    print("üßê Reflecting on recent performance...")
                    reflector_module.reflect_on_failures()
                except Exception as e:
                    print(f"‚ö†Ô∏è Reflection skipped: {e}")

        except Exception as e:
            print(f"‚ùå Task processing error: {e}")
            # Clear inbox if it crashes to prevent infinite crash loop
            with open(tasks_path, "w", encoding="utf-8") as f:
                 f.write("")
            time.sleep(10)

if __name__ == '__main__':
    # Start autonomous thread
    autonomous_thread = threading.Thread(target=autonomous_loop, daemon=False)
    autonomous_thread.start()
    
    # Keep main thread alive
    try:
        autonomous_thread.join()
    except KeyboardInterrupt:
        print("\nüõë Bridge shutdown requested")
